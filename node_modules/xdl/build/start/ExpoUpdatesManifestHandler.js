"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getManifestResponseAsync = getManifestResponseAsync;
exports.getManifestHandler = getManifestHandler;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _sdkRuntimeVersions() {
  const data = require("@expo/sdk-runtime-versions");

  _sdkRuntimeVersions = function () {
    return data;
  };

  return data;
}

function _url() {
  const data = require("url");

  _url = function () {
    return data;
  };

  return data;
}

function _uuid() {
  const data = require("uuid");

  _uuid = function () {
    return data;
  };

  return data;
}

function _internal() {
  const data = require("../internal");

  _internal = function () {
    return data;
  };

  return data;
}

function _ManifestHandler() {
  const data = require("./ManifestHandler");

  _ManifestHandler = function () {
    return data;
  };

  return data;
}

function getPlatformFromRequest(req) {
  const url = req.url ? (0, _url().parse)(req.url,
  /* parseQueryString */
  true) : null;
  const platform = (url === null || url === void 0 ? void 0 : url.query.platform) || req.headers['expo-platform'];

  if (!platform) {
    throw new Error('Must specify expo-platform header or query parameter');
  }

  return String(platform);
}

async function getManifestResponseAsync({
  projectRoot,
  platform,
  host
}) {
  var _expoConfig$runtimeVe;

  const headers = new Map(); // set required headers for Expo Updates manifest specification

  headers.set('expo-protocol-version', 0);
  headers.set('expo-sfv-version', 0);
  headers.set('cache-control', 'private, max-age=0');
  headers.set('content-type', 'application/json');
  const hostname = (0, _ManifestHandler().stripPort)(host);
  const [projectSettings, bundleUrlPackagerOpts] = await (0, _ManifestHandler().getPackagerOptionsAsync)(projectRoot);
  const projectConfig = (0, _config().getConfig)(projectRoot);
  const entryPoint = (0, _internal().resolveEntryPoint)(projectRoot, platform, projectConfig);

  const mainModuleName = _internal().UrlUtils.stripJSExtension(entryPoint);

  const expoConfig = projectConfig.exp;
  const expoGoConfig = await (0, _ManifestHandler().getExpoGoConfig)({
    projectRoot,
    projectSettings,
    mainModuleName,
    hostname
  });
  const hostUri = await _internal().UrlUtils.constructHostUriAsync(projectRoot, hostname);
  const runtimeVersion = (_expoConfig$runtimeVe = expoConfig.runtimeVersion) !== null && _expoConfig$runtimeVe !== void 0 ? _expoConfig$runtimeVe : expoConfig.sdkVersion ? (0, _sdkRuntimeVersions().getRuntimeVersionForSDKVersion)(expoConfig.sdkVersion) : null;

  if (!runtimeVersion) {
    throw new Error('Must specify runtimeVersion or sdkVersion in app.json');
  }

  const bundleUrl = await (0, _ManifestHandler().getBundleUrlAsync)({
    projectRoot,
    platform,
    projectSettings,
    bundleUrlPackagerOpts,
    mainModuleName,
    hostname
  }); // For each manifest asset (for example `icon`):
  // - set a field on the manifest containing a reference to the asset: iconAsset: { rawUrl?: string, assetKey?: string }
  // - gather the data needed to embed a reference to that asset in the expo-updates assets key

  const assets = await _internal().ProjectAssets.resolveAndCollectExpoUpdatesManifestAssets(projectRoot, expoConfig, path => bundleUrl.match(/^https?:\/\/.*?\//)[0] + 'assets/' + path);
  const expoUpdatesManifest = {
    id: (0, _uuid().v4)(),
    createdAt: new Date().toISOString(),
    runtimeVersion,
    launchAsset: {
      key: mainModuleName,
      contentType: 'application/javascript',
      url: bundleUrl
    },
    assets,
    metadata: {},
    // required for the client to detect that this is an expo-updates manifest
    extra: {
      eas: {},
      // TODO(wschurman): somehow inject EAS config in here if known
      expoClient: { ...expoConfig,
        hostUri
      },
      expoGo: expoGoConfig
    }
  };
  return {
    body: expoUpdatesManifest,
    headers
  };
}

function getManifestHandler(projectRoot) {
  return async (req, res, next) => {
    if (!req.url || (0, _url().parse)(req.url).pathname !== '/update-manifest-experimental') {
      next();
      return;
    }

    try {
      const {
        body,
        headers
      } = await getManifestResponseAsync({
        projectRoot,
        host: req.headers.host,
        platform: getPlatformFromRequest(req)
      });

      for (const [headerName, headerValue] of headers) {
        res.setHeader(headerName, headerValue);
      }

      res.end(JSON.stringify(body));

      _internal().Analytics.logEvent('Serve Expo Updates Manifest', {
        projectRoot,
        developerTool: _internal().Config.developerTool,
        runtimeVersion: body.runtimeVersion
      });
    } catch (e) {
      _internal().ProjectUtils.logError(projectRoot, 'expo', e.stack);

      res.statusCode = 520;
      res.end(JSON.stringify({
        error: e.toString()
      }));
    }
  };
}
//# sourceMappingURL=ExpoUpdatesManifestHandler.js.map