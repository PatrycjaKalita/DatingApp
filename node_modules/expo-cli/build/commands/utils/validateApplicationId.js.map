{"version":3,"sources":["../../../src/commands/utils/validateApplicationId.ts"],"names":["validateBundleId","value","test","validatePackage","cachedBundleIdResults","cachedPackageNameResults","getBundleIdWarningAsync","bundleId","url","response","json","JSON","parse","body","trim","resultCount","firstApp","results","message","formatInUseWarning","trackName","sellerName","getPackageNameWarningAsync","packageName","statusCode","Log","chalk","bold","dim","appName","author","id","italic"],"mappings":";;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAEO,SAASA,gBAAT,CAA0BC,KAA1B,EAAkD;AACvD,SAAO,mBAAmBC,IAAnB,CAAwBD,KAAxB,CAAP;AACD;;AAEM,SAASE,eAAT,CAAyBF,KAAzB,EAAiD;AACtD,SAAO,oDAAoDC,IAApD,CAAyDD,KAAzD,CAAP;AACD;;AAED,MAAMG,qBAA6C,GAAG,EAAtD;AACA,MAAMC,wBAAgD,GAAG,EAAzD;AAEA;AACA;AACA;AACA;AACA;;AACO,eAAeC,uBAAf,CAAuCC,QAAvC,EAAiF;AACtF;AACA,MAAIH,qBAAqB,CAACG,QAAD,CAAzB,EAAqC;AACnC,WAAOH,qBAAqB,CAACG,QAAD,CAA5B;AACD;;AAED,MAAI,EAAE,MAAM,gCAAoB,kBAApB,CAAR,CAAJ,EAAsD;AACpD;AACA,WAAO,IAAP;AACD;;AAED,QAAMC,GAAG,GAAI,2CAA0CD,QAAS,EAAhE;;AACA,MAAI;AAAA;;AACF,UAAME,QAAQ,GAAG,MAAM,oBAAID,GAAJ,CAAvB;AACA,UAAME,IAAI,GAAGC,IAAI,CAACC,KAAL,mBAAWH,QAAQ,CAACI,IAApB,mDAAW,eAAeC,IAAf,EAAX,CAAb;;AACA,QAAIJ,IAAI,CAACK,WAAL,GAAmB,CAAvB,EAA0B;AACxB,YAAMC,QAAQ,GAAGN,IAAI,CAACO,OAAL,CAAa,CAAb,CAAjB;AACA,YAAMC,OAAO,GAAGC,kBAAkB,CAACH,QAAQ,CAACI,SAAV,EAAqBJ,QAAQ,CAACK,UAA9B,EAA0Cd,QAA1C,CAAlC;AACAH,MAAAA,qBAAqB,CAACG,QAAD,CAArB,GAAkCW,OAAlC;AACA,aAAOA,OAAP;AACD;AACF,GATD,CASE,MAAM,CACN;AACD;;AACD,SAAO,IAAP;AACD;;AAEM,eAAeI,0BAAf,CAA0CC,WAA1C,EAAuF;AAC5F;AACA,MAAIlB,wBAAwB,CAACkB,WAAD,CAA5B,EAA2C;AACzC,WAAOlB,wBAAwB,CAACkB,WAAD,CAA/B;AACD;;AAED,MAAI,EAAE,MAAM,gCAAoB,iBAApB,CAAR,CAAJ,EAAqD;AACnD;AACA,WAAO,IAAP;AACD;;AAED,QAAMf,GAAG,GAAI,iDAAgDe,WAAY,EAAzE;;AACA,MAAI;AACF,UAAMd,QAAQ,GAAG,MAAM,oBAAID,GAAJ,CAAvB,CADE,CAEF;;AACA,QAAIC,QAAQ,CAACe,UAAT,KAAwB,GAA5B,EAAiC;AAC/B;AACA;AACA,YAAMN,OAAO,GAAI,mBAAkBO,eAAIC,KAAJ,CAAUC,IAAV,CACjCJ,WADiC,CAEjC,uBAAsBE,eAAIC,KAAJ,CAAUE,GAAV,CAAc,+BAAUpB,GAAV,CAAd,CAA8B,EAFtD;AAGAH,MAAAA,wBAAwB,CAACkB,WAAD,CAAxB,GAAwCL,OAAxC;AACA,aAAOA,OAAP;AACD;AACF,GAZD,CAYE,MAAM,CACN;AACD;;AACD,SAAO,IAAP;AACD;;AAED,SAASC,kBAAT,CAA4BU,OAA5B,EAA6CC,MAA7C,EAA6DC,EAA7D,EAAiF;AAC/E,SAAQ,eAAcN,eAAIC,KAAJ,CAAUC,IAAV,CAAeE,OAAf,CAAwB,OAAMJ,eAAIC,KAAJ,CAAUM,MAAV,CAClDF,MADkD,CAElD,qBAAoBL,eAAIC,KAAJ,CAAUC,IAAV,CAAeI,EAAf,CAAmB,EAFzC;AAGD","sourcesContent":["import got from 'got';\n\nimport Log from '../../log';\nimport { learnMore } from './TerminalLink';\nimport { isUrlAvailableAsync } from './url';\n\nexport function validateBundleId(value: string): boolean {\n  return /^[a-zA-Z0-9-.]+$/.test(value);\n}\n\nexport function validatePackage(value: string): boolean {\n  return /^[a-zA-Z][a-zA-Z0-9_]*(\\.[a-zA-Z][a-zA-Z0-9_]*)+$/.test(value);\n}\n\nconst cachedBundleIdResults: Record<string, string> = {};\nconst cachedPackageNameResults: Record<string, string> = {};\n\n/**\n * A quality of life method that provides a warning when the bundle ID is already in use.\n *\n * @param bundleId\n */\nexport async function getBundleIdWarningAsync(bundleId: string): Promise<string | null> {\n  // Prevent fetching for the same ID multiple times.\n  if (cachedBundleIdResults[bundleId]) {\n    return cachedBundleIdResults[bundleId];\n  }\n\n  if (!(await isUrlAvailableAsync('itunes.apple.com'))) {\n    // If no network, simply skip the warnings since they'll just lead to more confusion.\n    return null;\n  }\n\n  const url = `http://itunes.apple.com/lookup?bundleId=${bundleId}`;\n  try {\n    const response = await got(url);\n    const json = JSON.parse(response.body?.trim());\n    if (json.resultCount > 0) {\n      const firstApp = json.results[0];\n      const message = formatInUseWarning(firstApp.trackName, firstApp.sellerName, bundleId);\n      cachedBundleIdResults[bundleId] = message;\n      return message;\n    }\n  } catch {\n    // Error fetching itunes data.\n  }\n  return null;\n}\n\nexport async function getPackageNameWarningAsync(packageName: string): Promise<string | null> {\n  // Prevent fetching for the same ID multiple times.\n  if (cachedPackageNameResults[packageName]) {\n    return cachedPackageNameResults[packageName];\n  }\n\n  if (!(await isUrlAvailableAsync('play.google.com'))) {\n    // If no network, simply skip the warnings since they'll just lead to more confusion.\n    return null;\n  }\n\n  const url = `https://play.google.com/store/apps/details?id=${packageName}`;\n  try {\n    const response = await got(url);\n    // If the page exists, then warn the user.\n    if (response.statusCode === 200) {\n      // There is no JSON API for the Play Store so we can't concisely\n      // locate the app name and developer to match the iOS warning.\n      const message = `⚠️  The package ${Log.chalk.bold(\n        packageName\n      )} is already in use. ${Log.chalk.dim(learnMore(url))}`;\n      cachedPackageNameResults[packageName] = message;\n      return message;\n    }\n  } catch {\n    // Error fetching play store data or the page doesn't exist.\n  }\n  return null;\n}\n\nfunction formatInUseWarning(appName: string, author: string, id: string): string {\n  return `⚠️  The app ${Log.chalk.bold(appName)} by ${Log.chalk.italic(\n    author\n  )} is already using ${Log.chalk.bold(id)}`;\n}\n"],"file":"validateApplicationId.js"}