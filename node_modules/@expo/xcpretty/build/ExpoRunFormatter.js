"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExpoRunFormatter = void 0;
const chalk_1 = __importDefault(require("chalk"));
const path_1 = __importDefault(require("path"));
const Formatter_1 = require("./Formatter");
const MetroParser_1 = require("./MetroParser");
const getDependenciesFromPodfileLock_1 = require("./utils/getDependenciesFromPodfileLock");
const getNodeModuleName_1 = require("./utils/getNodeModuleName");
const getPackageJsonForPath_1 = require("./utils/getPackageJsonForPath");
const symbols_1 = require("./utils/symbols");
/**
 * A superset of `Formatter` which adds support for Metro build errors and cleaner formatting for Node projects.
 */
class ExpoRunFormatter extends Formatter_1.Formatter {
    constructor(props) {
        super(props);
        this.props = props;
        this.cachedPackages = {};
        this.nativeProjectRoot = path_1.default.join(props.projectRoot, 'ios');
    }
    static create(projectRoot, { xcodeProject, isDebug, } = {}) {
        var _a;
        const podfileLock = path_1.default.join(projectRoot, 'ios', 'Podfile.lock');
        const appName = ((_a = xcodeProject === null || xcodeProject === void 0 ? void 0 : xcodeProject.name.match(/.*\/(.*)\.\w+/)) === null || _a === void 0 ? void 0 : _a[1]) || '';
        const formatter = new ExpoRunFormatter({
            projectRoot,
            appName,
            podfile: getDependenciesFromPodfileLock_1.getDependenciesFromPodfileLock(podfileLock),
            isDebug,
        });
        return formatter;
    }
    get parser() {
        if (this._parser) {
            return this._parser;
        }
        this._parser = new MetroParser_1.MetroParser(this);
        return this._parser;
    }
    formatMetroAssetCollectionError(errorContents) {
        const results = `\n${chalk_1.default.red(symbols_1.ERROR +
            // Provide proper attribution.
            'Metro encountered an error:\n' +
            errorContents)}\n`;
        this.errors.push(results);
        return results;
    }
    shouldShowCompileWarning(filePath, lineNumber, columnNumber) {
        if (this.props.isDebug) {
            return true;
        }
        return !filePath.match(/node_modules/) && !filePath.match(/\/ios\/Pods\//);
    }
    formatFileOperation(props) {
        const title = this.getFileOperationTitle(props.type);
        const moduleNameTag = this.getPkgName(props.filePath, props.target);
        return Formatter_1.Formatter.format(title, [moduleNameTag, Formatter_1.Formatter.formatBreadCrumb(props.fileName, props.target, props.project)]
            .filter(Boolean)
            .join(' '));
    }
    formatPhaseScriptExecution(scriptName, target, project) {
        const moduleNameTag = this.getPkgName('', target);
        if (scriptName === 'Start Packager') {
            const port = process.env.RCT_METRO_PORT || '8081';
            const isDisabled = isTruthy(process.env.RCT_NO_LAUNCH_PACKAGER);
            const status = isDisabled ? 'disabled' : `http://localhost:${port}`;
            // Add some insight into if the bundler was started or not, and which port was used.
            if (isDisabled) {
                scriptName = chalk_1.default.gray(`${scriptName} (disabled)`);
            }
            else {
                scriptName = scriptName + chalk_1.default.gray(` on ${status}`);
            }
        }
        return Formatter_1.Formatter.format('Executing', [moduleNameTag, Formatter_1.Formatter.formatBreadCrumb(scriptName, target, project)]
            .filter(Boolean)
            .join(' '));
    }
    getPkgName(filePath, target) {
        let moduleName = getNodeModuleName_1.getNodeModuleName(filePath);
        if (!moduleName) {
            if (this.props.appName &&
                (target === this.props.appName || target === `Pods-${this.props.appName}`)) {
                moduleName = '';
            }
            else if (target && target in knownPackages) {
                moduleName = knownPackages[target];
            }
            else {
                const pkg = this.packageJsonForProject(target);
                if (pkg) {
                    moduleName = pkg.name;
                }
            }
        }
        return moduleName ? chalk_1.default.cyan(`${moduleName}`) : null;
    }
    getPodfile() {
        return this.props.podfile || {};
    }
    packageJsonForProject(project) {
        var _a;
        if (!project) {
            return null;
        }
        if (project in this.cachedPackages) {
            return this.cachedPackages[project];
        }
        const filePath = (_a = Object.values(this.getPodfile()[project] || {})[0]) !== null && _a !== void 0 ? _a : null;
        if (!filePath) {
            return null;
        }
        const pkg = getPackageJsonForPath_1.getPackageJsonForPath(path_1.default.join(this.nativeProjectRoot, filePath));
        if (pkg) {
            this.cachedPackages[project] = pkg;
        }
        return pkg !== null && pkg !== void 0 ? pkg : null;
    }
}
exports.ExpoRunFormatter = ExpoRunFormatter;
// A list of packages that aren't linked through cocoapods directly.
const knownPackages = {
    // Added to ReactCore as a `resource_bundle`
    'React-Core-AccessibilityResources': 'react-native',
    YogaKit: 'react-native',
    // flipper
    'Flipper-DoubleConversion': 'react-native',
    'Flipper-Folly': 'react-native',
    'OpenSSL-Universal': 'react-native',
    FlipperKit: 'react-native',
    Flipper: 'react-native',
    'Flipper-RSocket': 'react-native',
};
function isTruthy(value) {
    return value === 'true' || value === 1 || value === '1';
}
//# sourceMappingURL=ExpoRunFormatter.js.map