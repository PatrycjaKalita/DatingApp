"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assert = require("assert");
var removeSlash = require("remove-trailing-slash");
var looselyValidate = require("@segment/loosely-validate-event");
var serialize = require("serialize-javascript");
var Queue = require("bull");
var axios = require("axios");
var axiosRetry = require("axios-retry");
var ms = require("ms");
var uuid = require("uuid/v4");
var md5 = require("md5");
var isString = require("lodash.isstring");
var version = require("./package.json").version;
var winston = require("winston");
var logFormat = winston.format.printf(function (_ref) {
  var level = _ref.level,
      message = _ref.message,
      label = _ref.label,
      timestamp = _ref.timestamp;

  return timestamp + " [" + label + "] " + level + ": " + message;
});

var setImmediate = global.setImmediate || process.nextTick.bind(process);
var noop = function noop() {};

var Analytics = function () {
  /**
   * Initialize a new `Analytics` with your Segment project's `writeKey` and an
   * optional dictionary of `options`.
   *
   * @param {String} writeKey
   * @param {Object} [options] (optional)
   *   @property {Number} flushAt (default: 20)
   *   @property {Number} flushInterval (default: 10000)
   *   @property {String} host (default: required)
   *   @property {Boolean} enable (default: true)
   */

  function Analytics(writeKey, dataPlaneURL, options) {
    _classCallCheck(this, Analytics);

    options = options || {};

    assert(writeKey, "You must pass your project's write key.");
    assert(dataPlaneURL, "You must pass your data plane url.");

    this.queue = [];
    this.pQueue = undefined;
    this.pQueueInitialized = false;
    this.pQueueOpts = undefined;
    this.pJobOpts = {};
    this.state = "idle";
    this.writeKey = writeKey;
    this.host = removeSlash(dataPlaneURL);
    this.timeout = options.timeout || false;
    this.flushAt = Math.max(options.flushAt, 1) || 20;
    this.flushInterval = options.flushInterval || 20000;
    this.maxInternalQueueSize = options.maxInternalQueueSize || 20000;
    this.logLevel = options.logLevel || "info";
    this.flushed = false;
    Object.defineProperty(this, "enable", {
      configurable: false,
      writable: false,
      enumerable: true,
      value: typeof options.enable === "boolean" ? options.enable : true
    });

    this.logger = winston.createLogger({
      level: this.logLevel,
      format: winston.format.combine(winston.format.label({ label: "Rudder" }), winston.format.timestamp(), logFormat),
      transports: [new winston.transports.Console()]
    });

    axiosRetry(axios, { retries: 0 });
  }

  _createClass(Analytics, [{
    key: "addPersistentQueueProcessor",
    value: function addPersistentQueueProcessor() {
      var _isErrorRetryable = this._isErrorRetryable.bind(this);
      var rdone = function rdone(callbacks, err) {
        callbacks.forEach(function (callback_) {
          callback_(err);
        });
      };

      var payloadQueue = this.pQueue;
      var jobOpts = this.pJobOpts;

      this.pQueue.on("failed", function (job, error) {
        var jobData = eval("(" + job.data.eventData + ")");
        this.logger.error("job : " + jobData.description + " " + error);
      });

      // tapping on queue events
      this.pQueue.on("completed", function (job, result) {
        var jobData = eval("(" + job.data.eventData + ")");
        result = result || "completed";
        this.logger.debug("job : " + jobData.description + " " + result);
      });

      this.pQueue.on("stalled", function (job) {
        var jobData = eval("(" + job.data.eventData + ")");
        this.logger.warn("job : " + jobData.description + " is stalled...");
      });

      this.pQueue.process(function (job, done) {
        // job failed for maxAttempts or more times, push to failed queue
        // starting with attempt = 0
        var maxAttempts = jobOpts.maxAttempts || 10;
        var jobData = eval("(" + job.data.eventData + ")");
        if (jobData.attempts >= maxAttempts) {
          done(new Error("job : " + jobData.description + " pushed to failed queue after attempts " + jobData.attempts + " skipping further retries..."));
        } else {
          // process the job after exponential delay, if it's the 0th attempt, setTimeout will fire immediately
          // max delay is 30 sec, it is mostly in sync with a bull queue job max lock time
          setTimeout(function () {
            var _this = this;

            var req = jobData.request;
            req.data.sentAt = new Date();
            // if request succeeded, mark the job done and move to completed
            axios(req).then(function (response) {
              rdone(jobData.callbacks);
              done();
            }).catch(function (err) {
              // check if request is retryable
              if (_isErrorRetryable(err)) {
                var attempts = jobData.attempts;
                jobData.attempts = attempts + 1;
                // increment attempt
                // add a new job to queue in lifo
                // if able to add, mark the earlier job done with push to completed with a msg
                // if add to redis queue gives exception, not catching it
                // in case of redis queue error, mark the job as failed ? i.e add the catch block in below promise ?
                payloadQueue.add({ eventData: serialize(jobData) }, { lifo: true }).then(function (pushedJob) {
                  done(null, "job : " + jobData.description + " failed for attempt " + attempts + " " + err);
                }).catch(function (error) {
                  _this.logger.error("failed to requeue job " + jobData.description);
                  rdone(jobData.callbacks, error);
                  done(error);
                });
              } else {
                // if not retryable, mark the job failed and to failed queue for user to retry later
                rdone(jobData.callbacks, err);
                done(err);
              }
            });
          }, Math.min(30000, Math.pow(2, jobData.attempts) * 1000));
        }
      });
    }

    /**
     *
     * @param {*} queueOpts
     * {
     *    queueName: string = rudderEventsQueue,
     *    prefix: string = rudder
     *    isMultiProcessor: booloean = false
     *    redisOpts: {
     *      port?: number = 6379;
     *      host?: string = localhost;
     *      db?: number = 0;
     *      password?: string;
     *    },
     *    jobOpts: {
     *      maxAttempts: number = 10
     *    }
     * }
     * @param {*} callback
     *  All error paths from redis and queue will give exception, so they are non-retryable from SDK perspective
     *  The queue may not function for unhandled promise rejections
     *  this error callback is called when the SDK wants the user to retry
     */

  }, {
    key: "createPersistenceQueue",
    value: function createPersistenceQueue(queueOpts, callback) {
      var _this2 = this;

      if (this.pQueueInitialized) {
        this.logger.debug("a persistent queue is already initialized, skipping...");
        return;
      }

      this.pQueueOpts = queueOpts || {};
      this.pQueueOpts.isMultiProcessor = this.pQueueOpts.isMultiProcessor || false;
      if (!this.pQueueOpts.redisOpts) {
        throw new Error("redis connection parameters not present. Cannot make a persistent queue");
      }
      this.pJobOpts = this.pQueueOpts.jobOpts || {};
      this.pQueue = new Queue(this.pQueueOpts.queueName || "rudderEventsQueue", {
        redis: this.pQueueOpts.redisOpts,
        prefix: "{" + this.pQueueOpts.prefix + "}" || "{rudder}"
      });

      this.logger.debug("isMultiProcessor: " + this.pQueueOpts.isMultiProcessor);

      this.pQueue.isReady().then(function () {
        // at startup get active job, remove it, then add it in front of queue to retried first
        // then add the queue processor
        // if queue is isMultiProcessor, skip the above and add the queue processor
        if (_this2.pQueueOpts.isMultiProcessor) {
          _this2.addPersistentQueueProcessor();
          _this2.pQueueInitialized = true;
          callback();
        } else {
          _this2.pQueue.getActive().then(function (jobs) {
            _this2.logger.debug("success geting active jobs");
            if (jobs.length == 0) {
              _this2.logger.debug("there are no active jobs while starting up queue");
              _this2.addPersistentQueueProcessor();
              _this2.logger.debug("success adding process");
              _this2.pQueueInitialized = true;
              callback();
            } else {
              // since there is only once process, the count of active jobs will be 1 at max
              // moving active job is important as this job doesn't have a process function
              // and will later be retried which will mess event ordering
              if (jobs.length > 1) {
                _this2.logger.debug("number of active jobs at starting up queue > 1 ");
                callback(new Error("queue has more than 1 active job, move them to failed and try again"));
                return;
              }
              _this2.logger.debug("number of active jobs at starting up queue = " + jobs.length);
              jobs.forEach(function (job) {
                job.remove().then(function () {
                  _this2.logger.debug("success removed active job");
                  var jobData = eval("(" + job.data.eventData + ")");
                  jobData.attempts = 0;
                  _this2.pQueue.add({ eventData: serialize(jobData) }, { lifo: true }).then(function (removedJob) {
                    _this2.logger.debug("success adding removed job back to queue");
                    _this2.addPersistentQueueProcessor();
                    _this2.logger.debug("success adding process");
                    _this2.pQueueInitialized = true;
                    callback();
                  });
                }).catch(function (error) {
                  _this2.logger.error("failed to remove active job");
                  callback(error);
                });
              });
            }
          }).catch(function (error) {
            _this2.logger.error("failed geting active jobs");
            callback(error);
          });
        }
      }).catch(function (error) {
        _this2.logger.error("queue not ready");
        callback(error);
      });
    }
  }, {
    key: "_validate",
    value: function _validate(message, type) {
      try {
        looselyValidate(message, type);
      } catch (e) {
        if (e.message === "Your message must be < 32kb.") {
          this.logger.info("Your message must be < 32kb. This is currently surfaced as a warning. Please update your code", message);
          return;
        }
        throw e;
      }
    }

    /**
     * Send an identify `message`.
     *
     * @param {Object} message
     * @param {Function} [callback] (optional)
     * @return {Analytics}
     */

  }, {
    key: "identify",
    value: function identify(message, callback) {
      this._validate(message, "identify");
      this.enqueue("identify", message, callback);
      return this;
    }

    /**
     * Send a group `message`.
     *
     * @param {Object} message
     * @param {Function} [callback] (optional)
     * @return {Analytics}
     */

  }, {
    key: "group",
    value: function group(message, callback) {
      this._validate(message, "group");
      this.enqueue("group", message, callback);
      return this;
    }

    /**
     * Send a track `message`.
     *
     * @param {Object} message
     * @param {Function} [callback] (optional)
     * @return {Analytics}
     */

  }, {
    key: "track",
    value: function track(message, callback) {
      this._validate(message, "track");
      this.enqueue("track", message, callback);
      return this;
    }

    /**
     * Send a page `message`.
     *
     * @param {Object} message
     * @param {Function} [callback] (optional)
     * @return {Analytics}
     */

  }, {
    key: "page",
    value: function page(message, callback) {
      this._validate(message, "page");
      this.enqueue("page", message, callback);
      return this;
    }

    /**
     * Send a screen `message`.
     *
     * @param {Object} message
     * @param {Function} fn (optional)
     * @return {Analytics}
     */

  }, {
    key: "screen",
    value: function screen(message, callback) {
      this._validate(message, "screen");
      this.enqueue("screen", message, callback);
      return this;
    }

    /**
     * Send an alias `message`.
     *
     * @param {Object} message
     * @param {Function} [callback] (optional)
     * @return {Analytics}
     */

  }, {
    key: "alias",
    value: function alias(message, callback) {
      this._validate(message, "alias");
      this.enqueue("alias", message, callback);
      return this;
    }

    /**
     * Add a `message` of type `type` to the queue and
     * check whether it should be flushed.
     *
     * @param {String} type
     * @param {Object} message
     * @param {Function} [callback] (optional)
     * @api private
     */

  }, {
    key: "enqueue",
    value: function enqueue(type, message, callback) {
      if (this.queue.length >= this.maxInternalQueueSize) {
        this.logger.error("not adding events for processing as queue size " + this.queue.length + " >= than max configuration " + this.maxInternalQueueSize);
        return;
      }
      callback = callback || noop;

      if (!this.enable) {
        return setImmediate(callback);
      }

      if (type == "identify") {
        if (message.traits) {
          if (!message.context) {
            message.context = {};
          }
          message.context.traits = message.traits;
        }
      }

      message = _extends({}, message);
      message.type = type;

      message.context = _extends({
        library: {
          name: "analytics-node",
          version: version
        }
      }, message.context);

      message._metadata = _extends({
        nodeVersion: process.versions.node
      }, message._metadata);

      if (!message.originalTimestamp) {
        message.originalTimestamp = new Date();
      }

      if (!message.messageId) {
        // We md5 the messaage to add more randomness. This is primarily meant
        // for use in the browser where the uuid package falls back to Math.random()
        // which is not a great source of randomness.
        // Borrowed from analytics.js (https://github.com/segment-integrations/analytics.js-integration-segmentio/blob/a20d2a2d222aeb3ab2a8c7e72280f1df2618440e/lib/index.js#L255-L256).
        message.messageId = "node-" + md5(JSON.stringify(message)) + "-" + uuid();
      }

      // Historically this library has accepted strings and numbers as IDs.
      // However, our spec only allows strings. To avoid breaking compatibility,
      // we'll coerce these to strings if they aren't already.
      if (message.anonymousId && !isString(message.anonymousId)) {
        message.anonymousId = JSON.stringify(message.anonymousId);
      }
      if (message.userId && !isString(message.userId)) {
        message.userId = JSON.stringify(message.userId);
      }

      this.queue.push({ message: message, callback: callback });

      if (!this.flushed) {
        this.flushed = true;
        this.flush();
        return;
      }

      if (this.queue.length >= this.flushAt) {
        this.logger.debug("flushAt reached, trying flush...");
        this.flush();
      }

      if (this.flushInterval && !this.flushTimer) {
        this.logger.debug("no existing flush timer, creating new one");
        this.flushTimer = setTimeout(this.flush.bind(this), this.flushInterval);
      }
    }

    /**
     * Flush the current queue
     *
     * @param {Function} [callback] (optional)
     * @return {Analytics}
     */

  }, {
    key: "flush",
    value: function flush(callback) {
      var _this3 = this;

      // check if earlier flush was pushed to queue
      this.logger.debug("in flush");
      if (this.state == "running") {
        this.logger.debug("skipping flush, earlier flush in progress");
        return;
      }
      this.state = "running";
      callback = callback || noop;

      if (!this.enable) {
        this.state = "idle";
        return setImmediate(callback);
      }

      if (this.timer) {
        this.logger.debug("cancelling existing timer...");
        clearTimeout(this.timer);
        this.timer = null;
      }

      if (this.flushTimer) {
        this.logger.debug("cancelling existing flushTimer...");
        clearTimeout(this.flushTimer);
        this.flushTimer = null;
      }

      if (!this.queue.length) {
        this.logger.debug("queue is empty, nothing to flush");
        this.state = "idle";
        return setImmediate(callback);
      }

      var items = this.queue.slice(0, this.flushAt);
      var callbacks = items.map(function (item) {
        return item.callback;
      });
      var messages = items.map(function (item) {
        // if someone mangles directly with queue
        if (_typeof(item.message) == "object") {
          item.message.sentAt = new Date();
        }
        return item.message;
      });

      var data = {
        batch: messages,
        sentAt: new Date()
      };
      this.logger.debug("batch size is " + items.length);
      this.logger.silly("===data===", data);

      var done = function done(err) {
        callbacks.forEach(function (callback_) {
          callback_(err);
        });
        callback(err, data);
      };

      // Don't set the user agent if we're not on a browser. The latest spec allows
      // the User-Agent header (see https://fetch.spec.whatwg.org/#terminology-headers
      // and https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader),
      // but browsers such as Chrome and Safari have not caught up.
      var headers = {};
      if (typeof window === "undefined") {
        headers["user-agent"] = "analytics-node/" + version;
      }

      var req = {
        method: "POST",
        url: "" + this.host,
        auth: {
          username: this.writeKey
        },
        data: data,
        headers: headers
      };

      if (this.timeout) {
        req.timeout = typeof this.timeout === "string" ? ms(this.timeout) : this.timeout;
      }

      if (this.pQueue && this.pQueueInitialized) {
        var eventData = {
          description: "node-" + md5(JSON.stringify(req)) + "-" + uuid(),
          request: req,
          callbacks: callbacks,
          attempts: 0
        };
        // using serialize library as default JSON.stringify mangles with function/callback serialization
        this.pQueue.add({ eventData: serialize(eventData) }).then(function (pushedJob) {
          _this3.logger.debug("pushed job to queue");
          _this3.queue.splice(0, items.length);
          _this3.timer = setTimeout(_this3.flush.bind(_this3), _this3.flushInterval);
          _this3.state = "idle";
        }).catch(function (error) {
          _this3.timer = setTimeout(_this3.flush.bind(_this3), _this3.flushInterval);
          _this3.state = "idle";
          _this3.logger.error("failed to push to redis queue, in-memory queue size: " + _this3.queue.length);
          throw error;
        });
      } else if (!this.pQueue) {
        axios(_extends({}, req, {
          "axios-retry": {
            retries: 3,
            retryCondition: this._isErrorRetryable.bind(this),
            retryDelay: axiosRetry.exponentialDelay
          }
        })).then(function (response) {
          _this3.queue.splice(0, items.length);
          _this3.timer = setTimeout(_this3.flush.bind(_this3), _this3.flushInterval);
          _this3.state = "idle";
          done();
        }).catch(function (err) {
          _this3.logger.error("got error while attempting send for 3 times, dropping " + items.length + " events");
          _this3.queue.splice(0, items.length);
          _this3.timer = setTimeout(_this3.flush.bind(_this3), _this3.flushInterval);
          _this3.state = "idle";
          if (err.response) {
            var error = new Error(err.response.statusText);
            return done(error);
          }
          done(err);
        });
      } else {
        throw new Error("persistent queue not ready");
      }
    }
  }, {
    key: "_isErrorRetryable",
    value: function _isErrorRetryable(error) {
      // Retry Network Errors.
      if (axiosRetry.isNetworkError(error)) {
        return true;
      }

      if (!error.response) {
        // Cannot determine if the request can be retried
        return false;
      }

      this.logger.error("error status: " + error.response.status);
      // Retry Server Errors (5xx).
      if (error.response.status >= 500 && error.response.status <= 599) {
        return true;
      }

      // Retry if rate limited.
      if (error.response.status === 429) {
        return true;
      }

      return false;
    }
  }]);

  return Analytics;
}();

module.exports = Analytics;